/*	сохраняем данный файл в кодировке UTF-8		*/

	#include "ADS1115.h"


/*
Данный код работает в режиме прерывания ( функция самого прерывания описана ниже )

Настройки в CubeMX

Включаем шину I2C поддерживает как 100 так и 400 

Далее активируем пин на прерывание ( включаем глобальное прерывание ) для ножки ALERT у устанавливаем прерывание по FALLING
если у нас стоит в конфигурации COMP_POL_LOW //  Низкий активный уровень (по умолчанию)
прерывание будет генерировать низкий уровень сигнала.( на модуле данный пин подключен к VCC через резистор )

ниже в настройках переменной reg_setup указываем нужные нам параметры

В режиме при MUX_0_1 сигнал для измерения подключаем к	порт_0 к VCC  а порт_1 к GND

далее указываем адрес шины
Подключение
	вывода ADDR  |  Адрес микросхемы ADS1115
			GND		0x48  	 1001000
			VDD		0x49   	 1001001
			SDA		0x4A   	 1001010
			SCL		0x4B  	 1001011

	На модуле этот вывод подключен к GND проводу через резистор, 
	соответственно адрес будет равен значению 0x48 ( данный контакт можно не подключать )

*/


// в файле "ADS1115.h" указываем настройки адрес шины I2C и номер шины I2C --------------

//Connect ADDR pin to GND and I2C slave adress will be 0X48 .
#define ADS1115_ADDRESS 0x48<<1

// указываем нашу шину I2C
#define my_I2C			hi2c2

// не забываем ниже в коде переопределить функцию калбек на прерывание


//-----------------------------------------------------------------------------------------


// далее в main.c создаем две переменные одну из которой настраиваем как нам нужно ( смотри ниже )
//

///////////////  SETUP  ADS1115   /////////////////////////////////////////////////////////////////////////////////////

// переменная для установки и настройки модуля
				
uint16_t reg_setup = 	OS_FINISHED 			| 	//  режим одиночного преобразования
						MUX_0_1					|   //  (между контактом 0 и контактом 1) (по умолчанию)
						PGA_1					|	//  ( 1 - измеряет до 4,096 В - 1 бит = 0,125mV )
						MODE_SINGLE				|	//  одиночное преобразование с переходом в энергосберегающий режим (умолч)
						DR_128HZ				|	//  128 ГЦ (по умолчанию)
						COMP_MODE_HYSTERESIS 	|	// 	Компаратор с гистерезисом (по умолчанию)
						COMP_POL_LOW			|	//  Низкий активный уровень (по умолчанию)
						COMP_LAT_NOT_LATCH		|	//  Компаратор без “защелки” не запоминает значение при достижении порога (по умолчанию)
						COMP_QUE_1;					// Срабатывание после 1 достижения верхней или нижней границ
					

volatile uint16_t ADC_value = 0;	// переменная где храним результаты преобразования


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



	.........
	.........

main()=============================================================================================================================


//////////////////////////////////////////////////////////////////////////////////////////////////////////
		
		  HAL_NVIC_EnableIRQ( EXTI1_IRQn ); 	// включаем прерывание для ALERT
		  
		  // функция которая включает режим ( дергает ножкой ALERT ) когда данные готовы и их нужно считать ( для прерывания )
		  // true - on
		  // false - off
		  ADS1115_pulse_alert( true );
		
		  // запрос на преобразование "измерение" ( для одиночного режима вызываем каждый раз )
		  // для режима постоянного достаточно вызвать один раз
		  ADS1115_converting( reg_setup );
		  
///////////////////////////////////////////////////////////////////////////////////////////////////////////


	.........
	.........
	.........

while(1)===========================================================================================================================

	.........
	.........
	.........
	.........

=== end while(1) ==================================================================================================================


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin){
	
	if( GPIO_Pin == ALERT_INT_Pin ){	
		
		const uint8_t conversion_reginster = 0x00;	// Conversion reginster — отсюда читаем значение 2 байта
		
	    HAL_I2C_Mem_Read( &hi2c2, ADS1115_ADDRESS, conversion_reginster, 1, (uint8_t*)&ADC_value, 2, HAL_MAX_DELAY );
	  
		// меняем местами старший и младший бит
		ADC_value = ( ADC_value << 8 ) | ( ADC_value >> 8 );

	  
		 // ( чтобы получить значение напряжения в милливольтах ) Полученный результат умножаем на:
			// ( 6,144 В - 1 бит = 0,1875mV )
			// ( 4,096 В - 1 бит = 0,125mV )
			// ( 2,048 В - 1 бит = 0,0625mV ) (по умолчанию)
			// ( 1.024 В - 1 бит = 0.03125mV )
			// ( 0,512 В - 1 бит =0.015625mV )
			// ( 0,256 В - 1 бит = 0,0078125mV )
			// либо так var volt = (value*2.048)/32767.0
		 printf(" ADC = %d value   Volt = %f mV\r\n", ADC_value, ADC_value * 0.125 );// 1 бит = 0,125mV
		 // в данном режиме распиновка при MUX_0_1	 порт_0 VCC  а порт_1 GND
	 
	  
		  // запрос на преобразование "измерение" ( для одиночного режима вызываем каждый раз )
		  // для режима постоянного достаточно вызвать один раз
		  ADS1115_converting( reg_setup );
		
	}
	
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

=== end main() ====================================================================================================================
