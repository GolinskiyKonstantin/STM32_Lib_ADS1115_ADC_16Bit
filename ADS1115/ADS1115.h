/*

  ******************************************************************************
  * @file 			( фаил ):   ADS1115.h
  * @brief 		( описание ):  	
  ******************************************************************************
  * @attention 	( внимание ):	author: Golinskiy Konstantin	e-mail: golinskiy.konstantin@gmail.com
  ******************************************************************************
  
*/

#ifndef _ADS1115_H
#define _ADS1115_H

#ifdef __cplusplus
extern "C" {
#endif

/* Includes ----------------------------------------------------------*/

#include "main.h"

#include "stdbool.h"


//===========================================================================================
		/* 

			Подключение
			вывода ADDR  |  Адрес микросхемы ADS1115
					GND		0x48  	 1001000
					VDD		0x49   	 1001001
					SDA		0x4A   	 1001010
					SCL		0x4B  	 1001011

			На модуле этот вывод подключен к GND проводу через резистор, 
			соответственно адрес будет равен значению 0x48 ( данный контакт можно не подключать )

		*/

		//Connect ADDR pin to GND and I2C slave adress will be 0X48 .
		#define ADS1115_ADDRESS 0x48<<1

		// указываем нашу шину I2C
		#define my_I2C			hi2c2
		

//============================================================================================






/*

Данный код работает в режиме прерывания ( функция самого прерывания описана ниже )

Настройки в CubeMX

Включаем шину I2C поддерживает как 100 так и 400 

Далее активируем пин на прерывание ( включаем глобальное прерывание ) для ножки ALERT у устанавливаем прерывание по FALLING
если у нас стоит в конфигурации COMP_POL_LOW //  Низкий активный уровень (по умолчанию)
прерывание будет генерировать низкий уровень сигнала.( на модуле данный пин подключен к VCC через резистор )

ниже в настройках переменной reg_setup указываем нужные нам параметры

В режиме при MUX_0_1 сигнал для измерения подключаем к	порт_0 к VCC  а порт_1 к GND

далее указываем адрес шины
Подключение
	вывода ADDR  |  Адрес микросхемы ADS1115
			GND		0x48  	 1001000
			VDD		0x49   	 1001001
			SDA		0x4A   	 1001010
			SCL		0x4B  	 1001011

	На модуле этот вывод подключен к GND проводу через резистор, 
	соответственно адрес будет равен значению 0x48 ( данный контакт можно не подключать )




*/

// ARRD – задаёт один из 4-х возможных адресов модуля.  Данная функция имеет смысл при использовании нескольких ADS1115 на одной шине I2C.
// ALERT – выход компаратора, который удобно использовать для оповещения управляющего устройства.
// A0, A1, A2, A3 – входы АЦП, которые могут быть настроены как 4 одиночных канала или 2 дифференциальных. В последнем случае появляется возможность измерять разность потенциалов между выводами A0-A1 и A2-A3.

/*

	Память устройства состоит из 4х регистров.
		Адрес регистра	Предназначение
	0b00000000	0x00	Conversion reginster — отсюда читаем значение 2 байта
	0b00000001	0x01	Config register — сюда записываем конфигурацию (по умолчанию 0b1000010110000011)
	0b00000010	0x02	Lo_thresh register — регистр установки для компаратора, минимальное значение (по умолчанию 0b1000000000000000)
	0b00000011	0x03	Hi_thresh register — регистр установки для компаратора, максимальное значение (по умолчанию 0b111111111111111)

*/

//=================================================================================================
// Регистр настройки микросхемы состоит из 16 битного регистра

// 15-й бит регистра ( только на чтение ) OS Бит определяет состояние устройства ----------------------------------------
// При записи можно включить режим одиночного преобразования. Для этого нужно записать 1.

#define OS_PERFORMED					0x0000	// Выполняется преобразование
#define OS_FINISHED						0x8000	// Преобразование закончено

// Этот бит определяет статус преобразования, если бит равен 0- идет преобразование, 
// 1 – преобразование закончено. Путем чтения конфигурационного регистра можно определить готовность результата преобразования.

//--------------------------------------------------------------------------------------------------

// 14-й и 13-й и 12-й биты MUX Настройка мультиплексора ---------------------------------------------------
// ADS1115 имеет мультиплексор, который можно настроить для измерения напряжения между несколькими конфигурациями контактов
// Конфигурация мультиплексора. Управляет тем, между какими пинами считываем напряжение. 
// В конкретный промежуток времени плата может сравнивать напряжение только между какими-то двумя контактами.
// В нашем распоряжении A0, A1, A2, A3 и GND.

// дифференциальный режим ( например от -2.5В до +2.5В )
// при этом снимаем напряжение таким оброзом ( распиновка ) слева порт VCC справа GND
// например при MUX_0_1	 порт_0 VCC  а порт_1 GND
#define MUX_0_1							0x0000		// (между контактом 0 и контактом 1) (по умолчанию)
#define MUX_0_3							0x1000		// (между контактом 0 и контактом 3)
#define MUX_1_3							0x2000		// (между контактом 1 и контактом 3)
#define MUX_2_3							0x3000		// (между контактом 2 и контактом 3)

// однокональный режим ( например от 0 до +5В )
#define MUX_0_G							0x4000		// (между контактом 0 и GND)
#define MUX_1_G							0x5000		// (между контактом 1 и GND)
#define MUX_2_G 						0x6000		// (между контактом 2 и GND)
#define MUX_3_G 						0x7000		// (между контактом 3 и GND)

// В зависимости от настроек, эти входы могут использоваться как 4 одиночных канала измерения или как 2 дифференциальных
// В случае использования дифференциального режима, действует одно правило: при AINp>AINn напряжение определяется как положительное, а если AINp<AINn – напряжение будет отрицательным.
// Если же выставлен режим одиночных (несимметричных) входов, то измерения будут производиться исключительно между положительным входным сигналом и общим проводом ADS1115
//--------------------------------------------------------------------------------------------------

// 11-й и 10-й и 9-й биты PGA Коэффициент усиления усилителя	------------------------------------
// ADS1115 имеет усилитель с программируемым усилением (PGA), который может помочь вам измерять напряжения в различных диапазонах, а именно:
// Коэффициент усиления внутреннего усилителя. Чем меньше значение, тем точнее измерение, но меньше предел. Подаваемое напряжение не должно быть выше заданного порога для усилителя.

// Устанавливаем верхний придел измеряемого уровня ( например если будем мерить до 3.3В то ставим PGA_1 )
#define PGA_2_3							0x0000		// ( 2/3 - измеряет до 6,144 В - 1 бит = 0,1875mV )
#define PGA_1							0x0200		// ( 1 - измеряет до 4,096 В - 1 бит = 0,125mV )
#define PGA_2							0x0400		// ( 2 - измеряет до 2,048 В - 1 бит = 0,0625mV ) (по умолчанию)
#define PGA_4							0x0600		// ( 4 - измеряет до 1.024 В - 1 бит = 0.03125mV )
#define PGA_8							0x0800		// ( 8 - измеряет до 0,512 В - 1 бит =0.015625mV )
#define PGA_16							0x0A00		// ( 16 - измеряет до 0,256 В - 1 бит = 0,0078125mV )

// Всего доступно 6 уровней масштабирования. Каждый из них задаёт верхний предел измеряемого напряжения, выходить за рамки которого строго не рекомендуется. То же самое касается
// и напряжения питания модуля – оно должно быть равно или больше максимального предела измерений

//--------------------------------------------------------------------------------------------------

// 8-й бит регистра MODE Режим работы ( АЦП может работать в 2-х режимах )---------------------------

#define MODE_CONTINUOUS					0x0000		// непрерывное преобразование
#define MODE_SINGLE						0x0100		// одиночное преобразование с переходом в энергосберегающий режим (умолч)

//--------------------------------------------------------------------------------------------------

// 7-й и 6-й и 5-й бит DR Частота дискретизации ----------------------------------------------------
// 	Частота преобразования (дискретизации).

#define DR_8HZ							0x0000		// 8 ГЦ
#define DR_16HZ							0x0020		// 16 ГЦ
#define DR_32HZ							0x0040		// 32 ГЦ
#define DR_64HZ							0x0060		// 64 ГЦ
#define DR_128HZ						0x0080		// 128 ГЦ (по умолчанию)
#define DR_250HZ						0x00A0		// 250 ГЦ
#define DR_475HZ						0x00C0		// 475 ГЦ
#define DR_860HZ						0x00E0		// 860 ГЦ

//--------------------------------------------------------------------------------------------------

// 4-й бит COMP_MODE Тип компаратора	------------------------------------------------------------

#define COMP_MODE_HYSTERESIS			0x0000		// 	Компаратор с гистерезисом (по умолчанию)
#define COMP_MODE_NOT_HYSTERESIS		0x0010		//  Компаратор без гистерезиса

//--------------------------------------------------------------------------------------------------

// 3-й бит COMP_POL Полярность компаратора ---------------------------------------------------------
// Полярность компаратора. Задает полярность пина ALERT

#define COMP_POL_LOW					0x0000		//  Низкий активный уровень (по умолчанию)
#define COMP_POL_HIGH					0x0080		//  Высокий активный уровень

//--------------------------------------------------------------------------------------------------

// 2-й бит COMP_LAT Режим компаратора --------------------------------------------------------------

#define COMP_LAT_NOT_LATCH				0x0000		//  Компаратор без “защелки” не запоминает значение при достижении порога (по умолчанию)
#define COMP_LAT_LATCH					0x0040		//  Компаратор с “защелкой” запоминает значение

//--------------------------------------------------------------------------------------------------

// 1-й и 0-й бит COMP_QUE Управление компаратором --------------------------------------------------
// У этой настройки 2 функции. Если установить 11, то можно выключить компаратор. Остальные значение задают то,
// при каком количестве превышений верхнего или нижнего порогов компаратора значение пина ALERT будет 
// выставлено в логическую единицу.

#define COMP_QUE_1						0x0000		// Срабатывание после 1 достижения верхней или нижней границ
#define COMP_QUE_2						0x0001		// Срабатывание после 2х
#define COMP_QUE_4						0x0002		// Срабатывание после 4х
#define COMP_QUE_OFF					0x0003		// Отключение компоратора. Выставляет пин ALERT в 1 (по умолчанию)

//--------------------------------------------------------------------------------------------------

/*

	Если функция COMP_QUE включена, то в режиме непрерывного преобразования, после окончания каждого 
	измерения на выходе компаратора появляется импульс длительностью 8 мкс. 
	В режиме одиночного преобразования на выходе компаратора устанавливается низкий логический уровень 
	по окончании преобразования, если бит COMP_POL установлен в 0. Тем самым эту функцию удобно использовать 
	в качестве прерывания для управляющего устройства, чтобы не опрашивать постоянно бит OS, 
	а сразу считывать результат преобразования.
	
	Сначала в регистр АЦП Hi-tresh, передается значение 0xFFFF, а в регистр Lo_thresh значение 0x0000, 
	тем самым активируется функция компаратора об оповещении после окончания преобразования. 
	Далее настраивается конфигурационный регистр (Config register) с одновременным запуском преобразования. 
	После чего выполняется опрос вывода компаратора (ALERT/RDY) на факт окончания преобразования. 
	
*/

//=================================================================================================







/*
	******************************************************************************
	* @brief	 ( описание ):  функция запрос на преобразование "измерение" ( для одиночного режима вызываем каждый раз )
	* @param	( параметры ):	для режима постоянного достаточно вызвать один раз
	* @return  ( возвращает ):	

	******************************************************************************
*/
void ADS1115_converting( uint16_t config );
//------------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  функция которая включает режим ( дергает ножкой ALERT ) когда данные готовы и их нужно считать ( для прерывания )
	* @param	( параметры ):	включение или отключение передаем истину или лож
	* @return  ( возвращает ):	

	******************************************************************************
*/
void ADS1115_pulse_alert( bool status );
//------------------------------------------------------------------------------------


#ifdef __cplusplus
}
#endif

#endif	/*	_ADS1115_H */

/************************ (C) COPYRIGHT GKP *****END OF FILE****/
